function create_alfile_gait3d_pelvis213_torque(alfile)
% Create the Autolev source file
% This is done with custom code for this model.  Eventually we may interpret the .osim file
% so we can convert any model from Opensim to Autolev.
% NOTE: We may not continue with Autolev.  See, for example: http://pydy.org/ which could
% be a good alternative.
	global nbodies
	
	alfile_FK = strrep(alfile,'.al','_FK.al');
	fprintf('Making %s...\n', alfile_FK);
	fid = fopen(alfile_FK,'w');
	if (fid < 0)
		error('Could not write %s\n', alfile_FK);
	end
	nbodies = 0;
	rawcfile = strrep(alfile_FK,'.al','_raw.c');
		
	% preliminaries
	fprintf(fid,'%% This file was generated by %s on %s\n', mfilename,date);
	fprintf(fid,'%% Autolev source code for the gait3d_pelvis213_torque multibody model\n\n');
	fprintf(fid,'AUTOZ ON\n');
	% fprintf(fid,'OVERWRITE ALL\n');
	fprintf(fid,'PAUSE 0\n');
	fprintf(fid,'UnitSystem  kg,meter,sec\n');
	fprintf(fid,'Newtonian ground\n');
	fprintf(fid,'\n');
	
	% --------------------------------------------
	% Generalized coordinates q
	%
	% Our name    Name in the original .osim model
	% ---------------------------------------------
	% q1..........pelvis_rotation
	% q2..........pelvis_obliquity
	% q3..........pelvis_tilt
	% q4..........pelvis_tx
	% q5..........pelvis_ty
	% q6..........pelvis_tz
	% q7..........hip_flexion_r
	% q8..........hip_adduction_r
	% q9..........hip_rotation_r
	% q10.........knee_flexion_r
	% q11.........ankle_angle_r
	% q12.........subtalar_angle_r 
	% q13.........mtp_angle_r 
	% q14.........hip_flexion_l
	% q15.........hip_adduction_l
	% q16.........hip_rotation_l
	% q17.........knee_flexion_l
	% q18.........ankle_angle_l
	% q19.........subtalar_angle_l 
	% q20.........mtp_angle_l
	% q21.........lumbar_extension
	% q22.........lumbar_bending
	% q23.........lumbar_rotation
	% q24.........arm_flex_r
	% q25.........arm_add_r
	% q26.........arm_rot_r
	% q27.........elbow_flex_r
	% q28.........pro_sup_r
	% q29.........arm_flex_l
	% q30.........arm_add_l
	% q31.........arm_rot_l
	% q32.........elbow_flex_l
	% q33.........pro_sup_l
	ndof = 33;
	% ------------------------------------
	fprintf(fid,'MotionVariables'' q{%d}''''\n', ndof);   	% this generates: MotionVariables' q{33}''
	fprintf(fid,'VARIABLES G{%d}\n', 24);					% ground reaction force variables G1..G24
	fprintf(fid,'CONSTANTS par__bodyweight\n');				% body weight (Newtons)
	
	%-------------------------------------
	% Joint axis orientation vectors, with respect to the local reference frame of the parent
	% segment.  Developer of the model is responsible for ensuring that these are unit vectors.
	fprintf(fid, 'CONSTANTS par__Rankle1,    par__Rankle2,    par__Rankle3\n');
	fprintf(fid, 'CONSTANTS par__Rsubtalar1, par__Rsubtalar2, par__Rsubtalar3\n');
	fprintf(fid, 'CONSTANTS par__Rmtp1,                       par__Rmtp3\n');		% mtp2 is hard zero (as coded in addleg function)
	fprintf(fid, 'CONSTANTS par__Relbow1,    par__Relbow2,    par__Relbow3\n');
	fprintf(fid, 'CONSTANTS par__Rraduln1,   par__Rraduln2,   par__Rraduln3\n');
	fprintf(fid, 'CONSTANTS par__Lankle1,    par__Lankle2,    par__Lankle3\n');
	fprintf(fid, 'CONSTANTS par__Lsubtalar1, par__Lsubtalar2, par__Lsubtalar3\n');
	fprintf(fid, 'CONSTANTS par__Lmtp1,                       par__Lmtp3\n');		% mtp2 is hard zero (as coded in addleg function)
	fprintf(fid, 'CONSTANTS par__Lelbow1,    par__Lelbow2,    par__Lelbow3\n');
	fprintf(fid, 'CONSTANTS par__Lraduln1,   par__Lraduln2,   par__Lraduln3\n');
	
	% ------------------------------------
	% Pelvis
	% ------------------------------------
	% pelvis generalized coordinates using the rotation-obliquity-tilt sequence (R. Baker, Gait & Posture 13:1-6, 2001)
	addbody(fid, 'pelvis', 'ground', 	...
		'q4', 'q5', 'q6', 				...		% position				
		'BODY213', 'q1', 'q2', 'q3');			% orientation

	%------------------------------------
	% Legs
	%------------------------------------
	addleg(fid, 'R', 7);			% add a right leg, using DOFs q7..q13
	addleg(fid, 'L', 14);			% add a left leg, using DOFs q14..q20
	
	%------------------------------------
	% Torso
	%------------------------------------
	joint = 'back';					% this is how the joint was named in osim
	tx = ['par__' joint '_x'];
	ty = ['par__' joint '_y'];
	tz = '0';						% z position is hard zero
	fprintf(fid, 'CONSTANTS %s, %s\n', tx, ty);
	addbody(fid, 'torso', 'pelvis', ...					
		 tx, ty, tz, ...					% position
		 'BODY312', 'q21', 'q22', 'q23'); 	% orientation: flexion, right bend, left twist

	%------------------------------------
	% Arms
	%------------------------------------
	addarm(fid, 'R', 24);			% add a right arm, using DOFs q24..28
	addarm(fid, 'L', 29);			% add a left arm, using DOFs q29..q33
	
	%-----------------------------------------------------------------------------------------------------
	% Generate symbolic Jacobians
	%-----------------------------------------------------------------------------------------------------
	% generate matrices so we can generate Jacobians with respect to q, qd, qdd,
	% and G (ground reaction forces)
	genmatrix(fid, 'q', ndof);
	genmatrix(fid, 'qd', ndof);
	genmatrix(fid, 'qdd', ndof);
	fprintf(fid, 'dfk_dq    = ZEE(D(fk,q))\n');
	fprintf(fid, 'fkdot     = ZEE(DT(fk))\n');		% IS THIS OUTPUT NEEDED?  We can do fkdot = dfk/dq * qdot
	fprintf(fid, 'dfkdot_dq = ZEE(D(fkdot,q))\n');

	%-----------------------------------------------------------
	% Generate C code
	%-----------------------------------------------------------
	fprintf(fid, 'Encode fk, dfk_dq, fkdot, dfkdot_dq\n');
	fprintf(fid, 'Code Algebraic() %s\n', rawcfile);

	% close the file
	fclose(fid);

	% Open File for dynamics without derivatives
	alfile_dynNoDer = strrep(alfile,'.al','_NoDer.al');
	fprintf('Making %s...\n', alfile_dynNoDer);
	fid = fopen(alfile_dynNoDer,'w');
	if (fid < 0)
        error('Could not write %s\n', alfile_dynNoDer);
	end
	rawcfile = strrep(alfile_dynNoDer,'.al','_raw.c');
		
	% preliminaries
	fprintf(fid,'%% This file was generated by %s on %s\n', mfilename,date);
	fprintf(fid,'%% Autolev source code for the gait3d_pelvis213_torque multibody model\n\n');
	fprintf(fid,'AUTOZ ON\n');
	% fprintf(fid,'OVERWRITE ALL\n');
	fprintf(fid,'PAUSE 0\n');
	fprintf(fid,'\n');

	%--------------------------------------------------------------------
	% Call FK
	%--------------------------------------------------------------------
	fprintf(fid,'RUN %s\n', alfile_FK);
	fprintf(fid,'\n');

	%--------------------------------------------------------------------
	% Apply gravity
	%--------------------------------------------------------------------
	fprintf(fid, '%%------------------------------------------------------\n');
	fprintf(fid, 'CONSTANTS par__gravity_x, par__gravity_y, par__gravity_z\n');
	fprintf(fid, 'Gravity(Vector(ground, par__gravity_x, par__gravity_y, par__gravity_z))\n');

	%--------------------------------------------------------------------
	% Apply air drag force to the Trunk CM
	%--------------------------------------------------------------------
	fprintf(fid, '%%------------------------------------------------------\n');
	fprintf(fid, 'CONSTANTS par__wind, par__airdrag\n');
	fprintf(fid, 'airspeed> = V_pelvisO_Ground> - par__wind * ground1>\n');		% velocity of trunk CM, relative to the air
	fprintf(fid, 'VARIABLES sx, sy, sz, s\n');									% xyz components of airspeed, and magnitude
	fprintf(fid, 'sx = dot(airspeed>,ground1>)\n');
	fprintf(fid, 'sy = dot(airspeed>,ground2>)\n');
	fprintf(fid, 'sz = dot(airspeed>,ground3>)\n');
	% define magnitude of airspeed such that it can't be zero
	fprintf(fid, 's = sqrt(sx*sx + sy*sy + sz*sz + 1e-6)\n');						
	fprintf(fid, 'FORCE(groundO/pelvisO, -par__airdrag*s*airspeed>)\n');		% quadratic equation

	%--------------------------------------------------------------------
	% Apply ground reaction force/moment to each of the foot segments
	%--------------------------------------------------------------------
	fprintf(fid, '%%------------------------------------------------------\n');
	addgrf(fid, 'Rcalcaneus',1);
	addgrf(fid, 'Rtoes', 7);
	addgrf(fid, 'Lcalcaneus', 13);
	addgrf(fid, 'Ltoes', 19);
	ngrfseg = 4;					% number of segments in which GRF are applied
	
	%--------------------------------------------------------------------
	% Generate equations of motion, scaled to bodyweight
	%--------------------------------------------------------------------
	fprintf(fid, '%%------------------------------------------------------\n');
	fprintf(fid, 'f = ( Fr() + FrStar() ) / par__bodyweight\n');

	%-----------------------------------------------------------
	% Generate C code
	%-----------------------------------------------------------
	fprintf(fid, 'Encode f\n');
	fprintf(fid, 'Code Algebraic() %s\n', rawcfile);

	% close the file
	fclose(fid);

	% Open File for dynamics with derivatives
	alfile_dynDer = alfile;
	fprintf('Making %s...\n', alfile_dynDer);
	fid = fopen(alfile_dynDer,'w');
	if (fid < 0)
        error('Could not write %s\n', alfile_dynDer);
	end
	rawcfile = strrep(alfile_dynDer,'.al','_raw.c');
		
	% preliminaries
	fprintf(fid,'%% This file was generated by %s on %s\n', mfilename,date);
	fprintf(fid,'%% Autolev source code for the gait3d_pelvis213_torque multibody model\n\n');
	fprintf(fid,'AUTOZ ON\n');
	% fprintf(fid,'OVERWRITE ALL\n');
	fprintf(fid,'PAUSE 0\n');
	fprintf(fid,'\n');

	%--------------------------------------------------------------------
	% Call dynamics file without derivatives
	%--------------------------------------------------------------------
	fprintf(fid,'RUN %s\n', alfile_dynNoDer);
	fprintf(fid,'\n');

	%-----------------------------------------------------------------------------------------------------
	% Generate symbolic Jacobians
	%-----------------------------------------------------------------------------------------------------
	% generate matrices so we can generate Jacobians with respect to G (ground reaction forces)
	genmatrix(fid, 'G', 6*ngrfseg);
	fprintf(fid, 'df_dq     = ZEE(D(f,q))\n');
	fprintf(fid, 'df_dqd    = ZEE(D(f,qd))\n');
	fprintf(fid, 'df_dqdd   = ZEE(D(f,qdd))\n');
	fprintf(fid, 'df_dG     = ZEE(D(f,G))\n');

	%-----------------------------------------------------------
	% Generate C code
	%-----------------------------------------------------------
	fprintf(fid, 'Encode df_dq, df_dqd, df_dqdd, df_dG\n');
	fprintf(fid, 'Code Algebraic() %s\n', rawcfile);
	fprintf(fid, 'EXIT\n');

	% close the file
	fclose(fid);
	
	fprintf('Done.\n');
		
end
%=======================================================================
function addbody(fid, name, parentname, t1, t2, t3, rotationtype, r1, r2, r3) 
	% adds a body to the model
	
	global nbodies

	fprintf(fid, '%%------------------------------------------------------\n');
	
	% if name contains the string "massless_", it's a massless reference frame
	massless = ~isempty(strfind(name,'massless_'));
	if (massless)
		% Define a coordinate frame for the massless body
		name = strrep(name, 'massless_', '');		% strip off the "massless_" part from the name
		fprintf(fid,'FRAME %s\n', name);
	else
		% define the body and its mass properties
		fprintf(fid,'BODY %s\n', name);
		fprintf(fid,'MASS %s = par__%s_M\n', name, name);
		fprintf(fid,'INERTIA  %s, par__%s_Ixx, par__%s_Iyy, par__%s_Izz, par__%s_Ixy, par__%s_Iyz, par__%s_Ixz\n', ...
			name,name,name,name,name,name,name);
	end
	
	% point where body is connected to its parent, and its velocity
	point = [name 'Joint'];						
	fprintf(fid,'POINT %s\n', point);
	if strcmp(parentname, 'ground')
		fprintf(fid,'P_groundO_%s> = Vector(ground, %s, %s, %s)\n', point, t1, t2, t3);
		fprintf(fid,'V_%s_ground> = DT(P_groundO_%s>, ground)\n', point, point);
	else
		fprintf(fid,'P_%sJoint_%s> = Vector(%s, %s, %s, %s)\n', parentname, point, parentname, t1, t2, t3);
		fprintf(fid,'V2PTS(ground, %s, %sJoint, %s)\n', parentname, parentname, point);
	end
		
	% orientation and angular velocity of the body that was just added
	if strcmp(rotationtype,'SIMPROT')
		fprintf(fid,'SIMPROT(%s, %s, %s, %s)\n', parentname, name, r1, r2);
		fprintf(fid,'W_%s_ground> = W_%s_ground> + %s'' * %s\n', name, parentname, r2, r1);
	else
		fprintf(fid,'DIRCOS(%s, %s, %s, %s, %s, %s)\n', parentname, name, rotationtype, r1, r2, r3);					
		fprintf(fid,'ANGVEL(%s, %s, %s, %s, %s, %s)\n', parentname, name, rotationtype, r1, r2, r3);			
	end

	if (~massless)
		% center of mass position and velocity
		fprintf(fid,'CONSTANTS par__%s_CMx, par__%s_CMy, par__%s_CMz\n', name, name, name);
		fprintf(fid,'P_%s_%sO> = Vector(%s, par__%s_CMx, par__%s_CMy, par__%s_CMz)\n', point,name,name,name,name,name);
		fprintf(fid,'V2PTS(ground, %s, %s, %sO)\n', name,point,name); 	% generate velocity of CM relative to ground
	end

	% Add position and orientation to the forward kinematics array FK. This will contain
	% 12*Nsegments values for the whole model. FK does not include ground.
	% Forward kinematics is needed for marker tracking and for contact models.
	if (nbodies == 0)
		fprintf(fid,'fk = [');
	else
		fprintf(fid,'fk := [fk;');	
	end
	nbodies = nbodies + 1;
	% stored as a column of 12 values, position of origin and the rotation matrix elements, extracted row-wise
	fprintf(fid,'dot(P_groundO_%s>, ground1>);', point);
	fprintf(fid,'dot(P_groundO_%s>, ground2>);', point);
	fprintf(fid,'dot(P_groundO_%s>, ground3>);', point);
	fprintf(fid,'transpose(rows(ground_%s,1));', name);
	fprintf(fid,'transpose(rows(ground_%s,2));', name);
	fprintf(fid,'transpose(rows(ground_%s,3))]\n', name);
		
	fprintf(fid,'\n');

	% print name on the screen
	% fprintf('%s\n', name);
	
end
%==========================================================================
function addleg(fid, side, iq)
	% adds a leg to the model

	% fid.......File handle for writing Autolev code
	% side......(string) 'R' or 'L'
	% iq........(int) index of the first of the 7 DOF in the leg
	
	if side == 'R'
		sign = '';
	elseif side == 'L'
		sign = '-';
	else
		error('addleg: side must be R or L');
	end

	%------------------------------------
	% Femur
	%------------------------------------
	dof1 = ['q' num2str(iq)];				% flexion
	dof2 = [sign 'q' num2str(iq+1)];		% adduction
	dof3 = [sign 'q' num2str(iq+2)];		% internal rotation
	joint = [side 'hip'];
	femur = [side 'femur'];
	tx = ['par__' joint '_x'];
	ty = ['par__' joint '_y'];
	tz = ['par__' joint '_z'];
	fprintf(fid, 'constants %s, %s, %s\n', tx, ty, tz);
	addbody(fid, femur, 'pelvis', ...					
		tx, ty, tz, ...							% position
		'BODY312', dof1, dof2, dof3); 			% orientation
	
	%------------------------------------
	% Tibia
	%------------------------------------
	dof = ['q' num2str(iq+3)];			% knee angle
	tibia = [side 'tibia'];
	joint = [side 'knee'];
	
	% x and y position of knee in femur are functions of knee angle (moving center of rotation)
	% we use a 4th order polynomial (5 coefficients)
	% parameters: joint z and polynomial coefficients for joint x and y
	tx = [		  'par__' joint '_x1 * ' dof '^4' ...
				'+ par__' joint '_x2 * ' dof '^3' ...
				'+ par__' joint '_x3 * ' dof '^2' ...
				'+ par__' joint '_x4 * ' dof      ...
				'+ par__' joint '_x5'];		% expression for X position (function of dof)
	ty = [		  'par__' joint '_y1 * ' dof '^4' ...
				'+ par__' joint '_y2 * ' dof '^3' ...
				'+ par__' joint '_y3 * ' dof '^2' ...
				'+ par__' joint '_y4 * ' dof      ...
				'+ par__' joint '_y5'];		% expression for Y position (function of dof)
	fprintf(fid, 'constants par__%s_x{5}, par__%s_y{5}\n', joint, joint);
	
	addbody(fid, tibia, femur, ...
		tx, ty, '0', ...							% position
		'BODY312', dof, '0', '0');					% orientation
	
	%------------------------------------
	% Talus
	%------------------------------------
	dof = ['tan(q' num2str(iq+4) '/2)'];
	joint = [side 'ankle'];
	talus = [side 'talus'];
	tx = '0';
	ty = ['par__' joint '_y'];
	tz = '0';
	fprintf(fid, 'CONSTANT %s\n', ty);			% location of ankle joint in tibia (x and z are hard zeros)

	% we use Rodrigues parameters to rotate about an axis that is not one of the coordinate axes
	% http://en.wikipedia.org/wiki/Rotation_formalisms_in_three_dimensions
	% the X and Y of the axis must be inverted when we are on the left side
    r1 = [dof '* par__' joint '1'];             % expression for 1st rodrigues parameter
	r2 = [dof '* par__' joint '2'];             % expression for 2nd rodrigues parameter
	r3 = [dof '* par__' joint '3'];             % expression for 3rd rodrigues parameter

	addbody(fid, [side 'massless_talus'], tibia,	...
		'0', ty, '0', 		...			% position
		'RODRIGUES', r1, r2, r3)		% orientation
	
	%------------------------------------
	% Calcaneus
	%------------------------------------
	dof = ['tan(q' num2str(iq+5) '/2)'];
	joint = [side 'subtalar'];
	calcaneus = [side 'calcaneus'];
	tx = ['par__' joint '_x'];
	ty = ['par__' joint '_y'];
	tz = ['par__' joint '_z'];
	fprintf(fid, 'CONSTANTS %s, %s, %s\n', tx, ty, tz);

	% we use Rodrigues parameters to rotate about an axis that is not one of the coordinate axes
	% http://en.wikipedia.org/wiki/Rotation_formalisms_in_three_dimensions
	r1 = [dof '* par__' joint '1'];             % expression for 1st rodrigues parameter
	r2 = [dof '* par__' joint '2'];             % expression for 2nd rodrigues parameter
	r3 = [dof '* par__' joint '3'];             % expression for 3rd rodrigues parameter
    
	addbody(fid, calcaneus, talus,	...
		tx, ty, tz, 		...			% position
		'RODRIGUES', r1, r2, r3)		% orientation
		
	%------------------------------------
	% Midfoot
	%------------------------------------
	% to be inserted later

	%------------------------------------
	% Toes
	%------------------------------------
	dof = ['tan(q' num2str(iq+6) '/2)'];
	joint = [side 'mtp'];
	toes = [side 'toes'];
	tx = ['par__' joint '_x'];
	ty = ['par__' joint '_y'];
	tz = ['par__' joint '_z'];
	fprintf(fid, 'constants %s, %s, %s\n', tx, ty, tz);

	% we use Rodrigues parameters to rotate about an axis that is not one of the coordinate axes
	% http://en.wikipedia.org/wiki/Rotation_formalisms_in_three_dimensions
    r1 = [dof '* par__' joint '1'];             % expression for 1st rodrigues parameter
	r2 = '0';                                   % expression for 2nd rodrigues parameter
	r3 = [dof '* par__' joint '3'];             % expression for 3rd rodrigues parameter

	addbody(fid, toes, calcaneus,	...
		tx, ty, tz, 		...			% position
		'RODRIGUES', r1, r2, r3)		% orientation
	
end
%==========================================================================
function addarm(fid, side, iq)
	% adds an arm to the model

	% fid.......File handle for writing Autolev code
	% side......(string) 'R' or 'L'
	% iq........(int) index of the first of the 7 DOF in the leg
	
	if side == 'R'
		sign = '';
	elseif side == 'L'
		sign = '-';
	else
		error('addlimb: side must be R or L');
	end

	%------------------------------------
	% Humerus
	%------------------------------------
	dof1 = ['q' num2str(iq)];					% flexion
	dof2 = [sign 'q' num2str(iq+1)];			% adduction
	dof3 = [sign 'q' num2str(iq+2)];			% internal rotation
	humerus = [side 'humerus'];
	joint = [side 'acromial'];
	tx = ['par__' joint '_x'];
	ty = ['par__' joint '_y'];
	tz = ['par__' joint '_z'];
	fprintf(fid, 'CONSTANTS %s, %s, %s\n', tx, ty, tz);
	addbody(fid, humerus, 'torso', ...					
		tx, ty, tz, ...						% position
		'BODY312', dof1, dof2, dof3); 		% orientation
		
	%------------------------------------
	% Ulna
	%------------------------------------
	dof = ['tan(q' num2str(iq+3) '/2)'];				% elbow flexion
	joint = [side 'elbow'];
	ulna = [side 'ulna'];
	tx = ['par__' joint '_x'];
	ty = ['par__' joint '_y'];
	tz = ['par__' joint '_z'];
	fprintf(fid, 'CONSTANTS %s, %s, %s\n', tx, ty, tz);
	
	% we use Rodrigues parameters to rotate about an axis that is not one of the coordinate axes
	% http://en.wikipedia.org/wiki/Rotation_formalisms_in_three_dimensions
	r1 = [dof '* par__' joint '1'];             % expression for 1st rodrigues parameter
	r2 = [dof '* par__' joint '2'];             % expression for 2nd rodrigues parameter
	r3 = [dof '* par__' joint '3'];             % expression for 3rd rodrigues parameter

	addbody(fid, ulna, humerus,	...
		tx, ty, tz, 		...			% position
		'RODRIGUES', r1, r2, r3)		% orientation	
	
	%------------------------------------
	% Radius
	%------------------------------------
	dof = ['tan(q' num2str(iq+4) '/2)'];				% pro_sup is the name of this dof in osim model
	joint = [side 'raduln'];
	radius = [side 'radius'];
	tx = ['par__' joint '_x'];
	ty = ['par__' joint '_y'];
	tz = ['par__' joint '_z'];
	fprintf(fid, 'CONSTANTS %s, %s, %s\n', tx, ty, tz);
	
	% we use Rodrigues parameters to rotate about an axis that is not one of the coordinate axes
	% http://en.wikipedia.org/wiki/Rotation_formalisms_in_three_dimensions
	r1 = [dof '* par__' joint '1'];             % expression for 1st rodrigues parameter
	r2 = [dof '* par__' joint '2'];             % expression for 2nd rodrigues parameter
	r3 = [dof '* par__' joint '3'];             % expression for 3rd rodrigues parameter

	addbody(fid, radius, ulna,	...
		tx, ty, tz, 		...			% position
		'RODRIGUES', r1, r2, r3);		% orientation	

	%------------------------------------
	% Hand
	%------------------------------------
	% no degrees of freedom, wrist motion was locked in osim model and we keep it that way
	joint = [side 'wrist'];
	hand = [side 'hand'];
	tx = ['par__' joint '_x'];
	ty = ['par__' joint '_y'];
	tz = ['par__' joint '_z'];
	fprintf(fid, 'CONSTANTS %s, %s, %s\n', tx, ty, tz);
	
	addbody(fid, hand, radius,	...
		tx, ty, tz, 		...			% position
		'BODY123', '0', '0', '0');		% orientation	

end
%============================================================================
function genmatrix(fid, name, n)

	qname = name(1);			% first letter is used as qname
	
	% letter 2 and 3 determine if matrix elements must be q, q', or q''
	if numel(name) == 1
		suffix = '';
	elseif numel(name) == 2
		suffix = '''';
	elseif numel(name) == 3
		suffix = '''''';
	else
		error('genmatrix: name must have length 1, 2, or 3.');
	end
		
	fprintf(fid, '%s = [', name);
	for i = 1:n
		if (i<n) 
			fprintf(fid, '%s%d%s, ', qname, i, suffix);
		else
			fprintf(fid, '%s%d%s]\n', qname, i, suffix);
		end
	end

end
%============================================================================
function addgrf(fid, segment, igrf)
	% apply ground reaction force to a segment
	% GRF is represented by 6 variables: Fxyz, Mxyz in segment reference frame
	%
	% segment...........(string) segment where GRF should be applied
	% igrf..............(integer) index to the location of the 6 GRF variables in the G array 

	% Define a point on segment that coincides with the ground origin
	point = [segment 'GRF'];
	fprintf(fid, 'POINTS %s\n', point);
	fprintf(fid, 'P_groundO_%s> = 0>\n', point);
	fprintf(fid, 'V2PTS(ground, %s, %sO, %s)\n', segment, segment, point);	% compute its velocity, needed for equations of motion

	% Apply the ground reaction force and moment to the segment
	% Remember that the forces and moments in G are normalized to body weight, so convert to N and Nm
	fprintf(fid, 'FORCE(groundO/%s, par__bodyweight*VECTOR(ground, G%d, G%d, G%d))\n', point, igrf, igrf+1, igrf+2); 
	fprintf(fid, 'TORQUE(ground/%s, par__bodyweight*VECTOR(ground, G%d, G%d, G%d))\n', segment, igrf+3, igrf+4, igrf+5);

end
